Python Errors & Exceptions

	Exemplo 01:

		def Division(x, y):
			assert y != 0, "System Halted: existence attempted division by zero."
			return x / y

		try:
			print(Division(10,0))
		except AssertionError as err:
			print(f"{err}")
			
	# -------------------------------------------------------
			
	Exemplo 02:
	
		try:
			num1 = int(input("Number 01: "))
			num2 = int(input("Number 02: "))
			r = num1 / num2
		except KeyboardInterrupt as err:
			print(f"Error: {err}")
		except ValueError as err:
			print(f"Error: {err}")
		except IOError as err:
			print(f"Error: {err}")
		except ZeroDivisionError as err:
			print(f"Error: {err}")
		else:
			print(f"RESULT: {r}")
		finally:
			print("Finished!")
			
	# -------------------------------------------------------
			
	Exemplo 03:
	
		def div(x,y):
		if y == 0:
			# raise "Division by zero!", y
			raise ValueError("Division by zero: {}".format(y))
		return x / y

		print(div(10,0))
	
	# -------------------------------------------------------
	
	Exemplo 04:
	
		def div(x,y):
			try:
				if y == 0:
					raise ZeroDivisionError("Division By Zero!!!")
				return x / y
			except ZeroDivisionError as err:
				print(f"Error: {err}")
			else:
				print(f"No exception!")

		print(div(10,0))
		print(div(10,2))
	
	# -------------------------------------------------------
	
	Exemplo 05:
	
		class MyDivisionBYZero(ZeroDivisionError):
			def __init__(self, args):
				self.arg = args

		x = 10
		y = 0
		if y == 0:
			raise MyDivisionBYZero("Division By Zero!!!")
		else:
			print(f"{x}/{y} = {x/y}")
			
	# -------------------------------------------------------
	
	Exemplo 06 - Creating Custom Exceptions:
	
	class MyDivByZero(Exception):
		def __init__(self, y, message="sjashdjs djashdjr jashdas!!!"):
			self.message = message
			self.y = y
			super().__init__(self.message)

	def div(x,y):
		if y == 0:
			raise MyDivByZero(y, message="Division By Zero!!!!!!!!!")
		return x/y

	try:
		print(div(10,0))
	except MyDivByZero as err:
		print(f"Error: {err}")
		
	# -------------------------------------------------------
	
	Exemplo 07 - Re-Raising Exceptions:	
	
	def div(x,y):
	   try:
		  return x/y  
	   except ZeroDivisionError as e:
		  raise

	try:
	   print(div(10,0))
	except ZeroDivisionError as e:
	   print("Division By Zero!!!!!")

	# -------------------------------------------------------
	
	Exemplo 08 - Re-Raising Exceptions:	
	
	VERSÃƒO 01:
	
		def div(x,y):
		   try:
			  return x/y  
		   except ZeroDivisionError as e:
			  raise

		try:
		   print(div(10,0))
		except ZeroDivisionError as e:
		   raise RuntimeError from None
	   
	VERSÃƒO 02:
	 
		def div(x,y):
			try:
				return x/y  
			except ZeroDivisionError as e:
				raise

		try:
			print(div(10,0))
		except ZeroDivisionError as e:
			raise RuntimeError from None
			   
	# -------------------------------------------------------
	
	Exemplo 09 - Nested try Block in Python:

	a=10
	b=0
	try:
	   print ("This is outer try block")
	   try:
		  print (a/b)
	   except ZeroDivisionError:
		  print ("Division by 0")
	   finally:
		  print ("inside inner finally block")
		  
	except Exception:
	   print ("General Exception")
	finally:
	   print ("inside outer finally block")
	   
	# -------------------------------------------------------
	
	Exemplo 10 - Python - User-Defined Exceptions:
	
	class MyDivException(Exception):

		def __init__(self, y, message="dkdasjhdjas hdjas d"):
			self.y = y
			self.message = message
			super().__init__(self.message)

		def __str__(self):
			return f"Error: {self.message} with y = {self.y}."

	x = 10
	y = 0

	if y == 0:
		raise MyDivException(y, "Division By Zero!!!")
	else:
		print(x / y)
		
	# -------------------------------------------------------
	
Python - Logging

	Logging Ã© o processo de gravaÃ§Ã£o de mensagens durante a execuÃ§Ã£o de um programa 
	para fornecer informaÃ§Ãµes de tempo de execuÃ§Ã£o que podem ser Ãºteis para monitoramento, 
	depuraÃ§Ã£o e auditoria.
	
	In Python, logging is achieved through the built-in logging...
	
	Benefits of Logging:
	
		Debugging âˆ’ Ajuda a identificar e diagnosticar problemas capturando informaÃ§Ãµes relevantes 
		durante a execuÃ§Ã£o do programa.

		Monitoring âˆ’ Fornece insights sobre o comportamento e o desempenho do aplicativo.

		Auditing âˆ’ MantÃ©m um registro de eventos e aÃ§Ãµes importantes para fins de seguranÃ§a.

		Troubleshooting (SoluÃ§Ã£o de problemas) âˆ’ Facilita o rastreamento do fluxo do programa e dos 
		valores das variÃ¡veis para entender o comportamento inesperado.
	
	Componentes do registro Python:
	
	... para gerenciar e gerar mensagens de log de forma eficaz.

		Logger âˆ’ Ã‰ o principal ponto de entrada que vocÃª usa para emitir mensagens de log. 
		Cada instÃ¢ncia do registrador Ã© nomeada e pode ser configurada de forma independente.

		Handler  âˆ’ Ele determina para onde as mensagens de log sÃ£o enviadas. Os manipuladores 
		enviam mensagens de log para diferentes destinos, como console, arquivos, soquetes, etc.

		Formatter âˆ’ Ele especifica o layout das mensagens de log. Os formatadores definem a 
		estrutura dos registros de log especificando quais informaÃ§Ãµes incluir (por exemplo, 
		carimbo de data/hora, nÃ­vel de log, mensagem).

		Logger Level âˆ’ Ele define o nÃ­vel de gravidade das mensagens de log. Mensagens 
		abaixo deste nÃ­vel sÃ£o ignoradas. Os nÃ­veis comuns 
		incluem DEBUG, INFO, AVISO, ERRO e CRÃTICO.

		Filter âˆ’ SÃ£o os componentes opcionais que fornecem um controle mais preciso sobre quais 
		registros de log sÃ£o processados e emitidos por um manipulador.

	Uso
	
		Escolhendo o nÃ­vel certo âˆ’ Selecionar o nÃ­vel de registro apropriado garante que as 
		mensagens de log forneÃ§am informaÃ§Ãµes relevantes sem sobrecarregar os logs.

		Definindo nÃ­veis âˆ’ Registradores, manipuladores e mensagens de log especÃ­ficas 
		podem ser configurados com diferentes nÃ­veis para controlar quais mensagens sÃ£o 
		gravadas e onde sÃ£o enviadas.

		Hierarquia âˆ’ Os nÃ­veis de registro sÃ£o hierÃ¡rquicos, o que significa que definir 
		um nÃ­vel em um registrador tambÃ©m afeta os manipuladores e as mensagens de registro 
		associadas a ele.
	
	# -------------------------------------------------------	
	
	Exemplo 01:
	
		import logging

		# Basic logging configuration
		logging.basicConfig(
			level=logging.DEBUG,
			format="%(levelname)s --- %(asctime)s --- %(message)s"
		)

		def sum(x, y):
			logging.debug("Entering the 'sum' function...")
			result = x + y
			logging.debug(f"Calculated result: {result}")
			return result

		# Main application flow

		if __name__ == "__main__":
			logging.debug("Starting application...")
			logging.debug("Calling 'sum' function with arguments (10, 2)...")
			print(sum(10, 2))
			logging.debug("Printed result successfully.")
			logging.debug("Application finished.")

	Configurando registro:
		Essa configuraÃ§Ã£o permite que os desenvolvedores personalizem o 
		comportamento de registro de acordo com os requisitos de seu aplicativo 
		e o ambiente de implantaÃ§Ã£o.
	
	# -------------------------------------------------------
	
	Exemplo 02:
	
		import logging

		logger = logging.getLogger("myApp")
		logger.setLevel(logging.DEBUG)

		console_handler = logging.StreamHandler()
		console_handler.setLevel(logging.DEBUG)

		formatter = logging.Formatter("%(levelname)s --- %(asctime)s -- %(message)s")
		console_handler.setFormatter(formatter)
		logger.addHandler(console_handler)

		logger.debug("Debug message!")
		logger.info("Info message!")
		logger.warning("Warning message!")
		logger.error("Error message!")
		logger.critical("Critical message!")
		
	# -------------------------------------------------------

Python - Assertions

	AsserÃ§Ãµes em Python sÃ£o declaraÃ§Ãµes que afirmam ou assumem que uma condiÃ§Ã£o Ã© verdadeira. 
	Se a condiÃ§Ã£o for falsa, Python levanta um AssertionErro exceÃ§Ã£o.

	Exemplo 01:
	
		try:
			num = int(input("Enter a number: "))
			assert num > 0, "Negative numbers are not permitted."
			print("Positive!")
		except ValueError as err:
			print(f"{err}")
		except AssertionError as err:
			print(f"{err}")
	
	# -------------------------------------------------------
	
	ðŸ“Œ Boas prÃ¡ticas para produÃ§Ã£o:
	
		âœ… Use try-except para lidar com erros previsÃ­veis 
		   (ex: arquivos ausentes, entrada invÃ¡lida).

		âœ… Registre erros com logging para diagnosticar problemas.

		âœ… Valide tudo que vier de fora: input do usuÃ¡rio, resposta de API, 
		   dados de banco.

		âŒ Evite assert para verificaÃ§Ãµes importantes em ambientes reais.
		
		
Python - Built-in Exceptions

	Hierarquia:
	
		BaseException
			SystemExit
			KeyboardInterrupt
		Exception
			ArithmeticError
				FloatingPointError
				OverflowError
				ZeroDivisionError
			AttributeError
			EOFError
			ImportError
			LookupError
				IndexError
				KeyError
			MemoryError
			NameError
				UnboundLocalError
			OSError
				FileNotFoundError
			TypeError
			ValueError
		---(Many others)---
		
	
	# Handling Multiple Exceptions

		try:
			num = int(input("Enter a number: "))
			assert num > 0, "Negative numbers are not permitted."
			print("Positive!")
		except (ValueError, AssertionError) as err:
			print(f"{err}")
		else:
			print("Correct!")
		finally:
			print("Finished!")
				
	# Explicitly Raising Built-in Exceptions
	
		def div(x, y):
			if y == 0:
				raise ZeroDivisionError("Cannot divide by zero !!!")
			return x / y

		try:
			print(div(10,0))
		except ZeroDivisionError as err:
			print(f"{err}")



# ---------------------


Python - Custom Exceptions

class MyDivError(Exception):
		def __init__(self, message):
			self.message = message
			super().__init__(self.message)


	def div(x, y):
		if y == 0:
			raise MyDivError("Division by zero error.")    
		else:
			return x/y
		
	print(div(10,2))
	print(div(10,0))
	
