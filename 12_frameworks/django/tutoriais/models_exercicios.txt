ğŸ§  Lista de ExercÃ­cios para Construir o Modelo Person
ğŸ”¹ Parte 1: Fundamentos do Django ORM
Crie um projeto Django e uma app chamada people.

Configure o banco de dados e registre a app no settings.py.

Crie um modelo simples chamado Person com os campos: name, gender, birthday, email, salary, status.

ğŸ”¹ Parte 2: ValidaÃ§Ãµes Personalizadas
Crie o arquivo validators.py e implemente:

validate_gender

validate_birthday_to_register

validate_salary

validate_email

Adicione essas validaÃ§Ãµes aos campos correspondentes no modelo Person.

Use RegexValidator para validar o formato do email.

ğŸ”¹ Parte 3: Constraints e Meta
Adicione UniqueConstraint para garantir unicidade do email.

Adicione CheckConstraint para:

Validar os valores possÃ­veis de gender.

Garantir que salary esteja entre 1 e 9.999.999.999.

Validar que status seja booleano.

Configure db_table, managed, e Meta.verbose_name_plural.

ğŸ”¹ Parte 4: Managers e QuerySets Personalizados
Crie a classe PersonQuerySet com mÃ©todos como:

with_pk

with_name

with_salary_above

with_salary_under

with_max_salary

with_min_salary

with_salary_above_avg

with_salary_under_avg

Crie PersonManager que retorna PersonQuerySet e delega os mÃ©todos.

Crie PersonAdminManager que filtra apenas registros com status=True.

Adicione os managers manager, admin, e queryset ao modelo Person.

ğŸ”¹ Parte 5: MÃ©todos Especiais e Proxy
Implemente __str__ para retornar "{self.pk} - {self.name}".

Implemente get_absolute_url usando reverse.

Sobrescreva save para chamar full_clean() antes de salvar.

Crie a classe MyPerson como proxy de Person, ordenando por name.

ğŸ”¹ Parte 6: Testes e Fixtures
Crie fixtures com dados de exemplo (people.json).

Teste os mÃ©todos do QuerySet e dos managers no shell do Django.

Crie views e templates para listar e detalhar pessoas usando get_absolute_url.

Utilizando:

ğŸ§© Lista de Usos PrÃ¡ticos com o Modelo Person
ğŸ”¹ 1. InicializaÃ§Ã£o do Ambiente Django
Configurar DJANGO_SETTINGS_MODULE e executar django.setup() para acesso ao ORM fora do ambiente padrÃ£o.

ğŸ”¹ 2. OperaÃ§Ãµes de AgregaÃ§Ã£o com ORM
Calcular estatÃ­sticas com aggregate():

MÃ©dia, soma, mÃ­nimo, mÃ¡ximo e contagem de salÃ¡rios.

Agrupar e anotar com annotate():

Agrupar por nome e mostrar salÃ¡rio mÃ¡ximo.

Filtrar com expressÃµes Q e F.

ğŸ”¹ 3. Uso de Cursores SQL
Executar SQL direto com connection.cursor():

SELECT * FROM PERSON usando o banco padrÃ£o.

Executar com connections['my_database'].cursor() para mÃºltiplos bancos.

ğŸ”¹ 4. Procedures e Consultas Customizadas
Chamar stored procedure com callproc('get_person_by_name', [name]).

Criar funÃ§Ã£o com @non_atomic_requests('my_database') para consultas fora de transaÃ§Ãµes.

ğŸ”¹ 5. CriaÃ§Ã£o e ExclusÃ£o de Registros
Criar pessoa com Person.manager.create(...).

Excluir pessoa com Person.manager.filter(...).delete().

ğŸ”¹ 6. TransaÃ§Ãµes e Controle de Erros
Usar @atomic para garantir atomicidade.

Usar transaction.on_commit() para aÃ§Ãµes pÃ³s-commit.

Capturar IntegrityError e realizar rollback() manual.

ğŸ”¹ 7. OperaÃ§Ãµes com MÃºltiplos Bancos
Usar .using('my_database') para operaÃ§Ãµes especÃ­ficas.

Buscar pessoa com maior pk no banco alternativo.

Salvar e deletar registros em my_database.

ğŸ”¹ 8. CriaÃ§Ã£o em Massa (Bulk)
Usar bulk_create() para inserir mÃºltiplos registros.

Preparar ambiente com delete_person_to_bulk_create().

ğŸ”¹ 9. Mensagens PÃ³s-AÃ§Ã£o
Usar functools.partial() com transaction.on_commit() para exibir mensagens como "Successfully created."

ğŸ”¹ 10. ExtensÃµes AvanÃ§adas
Preparar uso de db_tablespace e models.Index para otimizaÃ§Ã£o de Ã­ndices e tablespaces.
