Python - Multithreading

	Em Python, o multithreading permite executar v√°rios threads simultaneamente dentro de um 
	√∫nico processo, o que tamb√©m √© conhecido como paralelismo baseado em thread. Isso significa 
	que um programa pode executar v√°rias tarefas ao mesmo tempo, aumentando sua efici√™ncia e 
	capacidade de resposta.

		threading.activeCount()  : Retorna o n√∫mero de objetos thread que est√£o ativos. 
		threading.currentThread(): Retorna o objeto thread do controle de thread do chamador. 
		threading.enumerate()    : Retorna uma lista de todos os objetos thread que est√£o atualmente ativos. 
		run() 					 : O m√©todo run() √© o ponto de entrada de uma thread. 
		start() 				 : O m√©todo start() inicia uma thread chamando o m√©todo run. 
		join([time]) 			 : O join() espera que as threads terminem. 
		isAlive() 				 : O m√©todo isAlive() verifica se uma thread ainda est√° em execu√ß√£o. 
		getName() 				 : O m√©todo getName() retorna o nome de uma thread. 
		setName() 				 : O m√©todo setName() define o nome de uma thread.


	_thread: n√≠vel mais baixo (baixo n√≠vel)
	
		√â um m√≥dulo mais simples e direto.
		Cria threads com menos controle (sem .join(), .start() 
		ou gerenciamento de exce√ß√µes).
		Ideal se voc√™ precisa s√≥ disparar uma fun√ß√£o em segundo plano 
		de forma bem r√°pida e leve ‚Äî por exemplo, scripts muito simples 
		ou prot√≥tipos r√°pidos.
		Menor overhead, mas tamb√©m mais arriscado de usar.
		
		Como usar o _thread:
		
			Exemplo 01:
		
				import _thread
				import time

				def print_thread(name, delay, limit):
					i = 0
					while i < limit:
						print(f"- {name}")
						time.sleep(delay)
					i += 1

				# Iniciando a thread corretamente
				_thread.start_new_thread(print_thread, ("thread 01", 2, 5))

				# Pausa principal para permitir que a thread termine (s√≥ para demonstra√ß√£o)
				time.sleep(11)
	
	
	threading: n√≠vel mais alto (alto n√≠vel)
		
		Recomendado para aplica√ß√µes reais e complexas.
		Oferece m√©todos robustos como .start(), .join(), .is_alive(), locks, 
		controle de exce√ß√µes e at√© classes personalizadas com Thread.
		Muito mais f√°cil de depurar, gerenciar e escalar.
	
		Criar e iniciar threads usando o m√≥dulo de threading:
		
			Exemplo 01:
	
				import time
				import threading

				def print_thread(name, delay, limit):
					i = 0
					while i < limit:
						print(f"- {threading.current_thread().name}: {time.time()}")
						time.sleep(delay)
						i+=1
					print(f"{name} is done!")


				t2 = threading.Thread(target=print_thread, args=("Thread 01", 3, 5))
				t1 = threading.Thread(target=print_thread, args=("Thread 02", 2, 5))
				t3 = threading.Thread(target=print_thread, args=("Thread 03", 1, 5))

				t2.start()
				t1.start()
				t3.start()

				time.sleep(7)
				print(f"{threading.current_thread().name} is done!")

				t2.join()
				t1.join()
				t3.join()
			
	
		Exemplo 02:
	
				import time
				import threading

				def print_thread(name, delay, limit):
					i = 0
					while i < limit:
						print(f"- {threading.current_thread().name}: {time.time()}")
						time.sleep(delay)
						i+=1

				threads = []

				for i in range(1,4):
					t = threading.Thread(target=print_thread, args=(f"Thread {i}", 3, 5))
					threads.append(t)
					t.start()

				time.sleep(7)
				print(f"{threading.current_thread().name} is done!")

				for t in threads:
					t.join()
					print(f"{t.name} done!")
					
	
	Multithreaded Priority Queue

		get()	: Remove e retorna um item da fila.
		put()	: Adiciona um item √† fila.
		qsize()	: Retorna o n√∫mero de itens atualmente na fila.
		empty()	: Retorna True se a fila estiver vazia; caso contr√°rio, retorna False.
		full()	: Retorna True
		

Python - Semaforo:

	... controlar o acesso simult√¢neo a um recurso compartilhado por m√∫ltiplas threads.
	... limitar o n√∫mero de threads que podem acessar uma parte cr√≠tica do c√≥digo ao mesmo tempo.
	
	Como funciona?
	
		O sem√°foro mant√©m um contador interno.
		Quando uma thread chama acquire(), o contador √© decrementado.
			Se o contador for maior que zero, a thread continua.
			Se for zero, a thread espera at√© que outra thread libere o sem√°foro.
		Quando uma thread termina sua tarefa, ela chama release(), que incrementa o contador e permite 
		que outra thread prossiga.
		
		Exemplo 01:
		
			import threading
			import time

			# S√≥ 2 threads podem entrar por vez
			semaforo = threading.Semaphore(2)

			def tarefa(nome):
				with semaforo:
					print(f"{nome} entrou na se√ß√£o cr√≠tica")
					time.sleep(1)
					print(f"{nome} saiu da se√ß√£o cr√≠tica")

			threads = []
			for i in range(5):
				t = threading.Thread(target=tarefa, args=(f"Thread-{i}",))
				threads.append(t)
				t.start()

			for t in threads:
				t.join()
				
		
		Exemplo 02:

			import time
			import threading

			semaphore  = threading.Semaphore(2)

			def print_thread(name, delay, limit):
				with semaphore:
					i = 0
					while i < limit:
						print(f"- {threading.current_thread().name}: {time.time()}")
						time.sleep(delay)
						i+=1
					print(f"{name} is done!")

			t4 = threading.Thread(target=print_thread, args=("Thread 03", 1, 5))
			t2 = threading.Thread(target=print_thread, args=("Thread 01", 3, 5))
			t1 = threading.Thread(target=print_thread, args=("Thread 02", 2, 5))
			t3 = threading.Thread(target=print_thread, args=("Thread 04", 1, 5))

			t4.start()
			t2.start()
			t1.start()
			t3.start()

			time.sleep(7)
			print(f"{threading.current_thread().name} is done!")

			t4.join()
			t2.join()
			t1.join()
			t3.join()
	

Executando threars de maneira mais simples:

	Exemplo 01:

		from threading import Thread
		import time

		def sum(x, y):
			time.sleep(3)
			print(x + y)

		def greeting(name):
			time.sleep(2)
			print(f"Hello, {name}!")

		def message():
			print("Basic function is running concurrently...")

		Thread(target=sum, args=(10, 3)).start()
		Thread(target=message).start()
		Thread(target=greeting, args=("Anderson", )).start()


Estender a Classe Thread

	Exemplo 01:

		import threading
		import time

		def print_message(name, delay, limit):
			i = 0
			while i < limit:
				print(f"{name}: {time.time()}")
				time.sleep(delay)
				i+=1

		class myThread(threading.Thread):
			def __init__(self, **kwargs):
				threading.Thread.__init__(self)
				self.name = kwargs["name"]
				self.delay = kwargs["delay"]
				self.limit = kwargs["limit"]

			def run(self):
				print(f"{self.name} is started.")
				print_message(self.name, self.delay, self.limit)
				print(f"{self.name} is done!")

		t1 = myThread(name="Thread 01", delay=1, limit=5)
		t2 = myThread(name="Thread 02", delay=3, limit=2)
		t3 = myThread(name="Thread 03", delay=2, limit=3)

		t3.start()
		t1.start()
		t2.start()

		time.sleep(2)
		print("Exiting MainThread!")

	
	
Python - Joining the Threads

	... unir os threads significa usar o juntar-se () m√©todo para esperar que um 
	thread termine antes de passar para outros. 
	
	Joining Threads com join() para thread

		Exemplo 01:

			import time
			import threading

			def print_message(name, delay, limit):
				i = 0
				while i < limit:
					print(f"{name}: {time.time()}")
					time.sleep(delay)
					i+=1

			class myThread(threading.Thread):
				def __init__(self, **kwargs):
					threading.Thread.__init__(self)
					self.name = kwargs["name"]
					self.delay = kwargs["delay"]
					self.limit = kwargs["limit"]

				def run(self):
					print(f"{self.name} is started!") 
					print_message(self.name, self.delay, self.limit)
					print(f"{self.name} is done!") 

			t1 = myThread(name="Thread 01", delay=1, limit=5)
			t2 = myThread(name="Thread 02", delay=3, limit=2)
			t3 = myThread(name="Thread 03", delay=2, limit=3)
			t1.start()
			t1.join()
			t2.start()
			t2.join()
			t3.start()
			t3.join()
			time.sleep(4)
			print("MainThread is done!") 



	Joining com timeout num dos join().

		Exemplo 01:

			import time
			import threading

			def print_message(name, delay, limit):
				i = 0
				while i < limit:
					print(f"{name}: {time.time()}")
					time.sleep(delay)
					i+=1

			class myThread(threading.Thread):
				def __init__(self, **kwargs):
					threading.Thread.__init__(self)
					self.name = kwargs["name"]
					self.delay = kwargs["delay"]
					self.limit = kwargs["limit"]

				def run(self):
					print(f"{self.name} is started!") 
					print_message(self.name, self.delay, self.limit)
					print(f"{self.name} is done!") 

			t1 = myThread(name="Thread 01", delay=1, limit=5)
			t2 = myThread(name="Thread 02", delay=3, limit=2)
			t3 = myThread(name="Thread 03", delay=2, limit=3)
			t1.start()
			t1.join(timeout=0.5) # da uma atrasada na thread.
			t2.start()
			t2.join()
			t3.start()
			t3.join()
			time.sleep(4)
			print("MainThread is done!") 
	

Python - Naming the Threads

	Renaming Thread:
	
		Exemplo 01:

			import threading
			import time

			def print_message(name, delay, limit):
				i = 0
				while i < limit:
					print(f"{threading.currentThread().name}: {time.time()}")
					time.sleep(delay)
					i+=1

			class myThread(threading.Thread):
				def __init__(self, **kwargs):
					threading.Thread.__init__(self)
					self.name = kwargs["name"]
					self.delay = kwargs["delay"]
					self.limit = kwargs["limit"]

				def run(self):
					# rename thread:
					threading.currentThread().name = self.name
					#
					print(f"{self.name} is started.")
					print_message(self.name, self.delay, self.limit)
					print(f"{self.name} is done!")

			t1 = myThread(name="Thread 01", delay=1, limit=5)
			t2 = myThread(name="Thread 02", delay=3, limit=2)
			t3 = myThread(name="Thread 03", delay=2, limit=3)

			t3.start()
			t1.start()
			t2.start()

			time.sleep(2)
			print("Exiting MainThread!")
	
# ----------------------------------------------------------------------------

Python - Thread Scheduling

	O Python n√£o possui suporte interno para controlar prioridades de thread ou 
	pol√≠ticas de agendamento diretamente. Em vez disso, ele depende do agendador 
	de threads do sistema operacional.
	
	Agendamento de Threads usando a Classe Timer
	
		Exemplo 01:

			import time
			import threading

			def print_time():
				print(f"current_time: {time.ctime(time.time())}")

			print(f"start: {time.ctime(time.time())}")

			t1 = threading.Timer(3, print_time, args=())
			t1.start()
			t1.join()
			print(f"finish: {time.ctime(time.time())}")
	
	# --------------
	
	Programando Threads usando o agendar M√≥dulo
	
		Exemplo 01:
		
			import time
			import sched

			scheduler = sched.scheduler(time.time, time.sleep)

			def print_time(name):
				print(f"{name}: {time.ctime(time.time())}")

			print(f"start : {time.ctime(time.time())}")

			scheduler.enter(3, 1, print_time, ("EVENT_01",))
			scheduler.enter(5, 1, print_time, ("EVENT_02",))
			scheduler.run()

			print(f"finish: {time.ctime(time.time())}")

	# --------------

		Exemplo 02:

			import time
			import sched

			scheduler = sched.scheduler(time.time, time.sleep)

			def print_time(current_event):
				print(f"{current_event}: {time.ctime(time.time())}")

			for i in range(5):
				scheduler.enter(i + 1, 1, print_time, (f"EVENT_{i + 1}",))

			print(f"START : {time.ctime(time.time())}")
			scheduler.run()
			print(f"FINISH: {time.ctime(time.time())}")
	
	
	
Python - Thread Pools

	Um pool de threads √© uma cole√ß√£o de threads gerenciados por um pool. 
	Cada fio na piscina √© chamado de fio de trabalhador ou de trabalhador. 
	Esses threads podem ser reutilizados para executar v√°rias tarefas, 
	o que reduz a carga de criar e destruir threads repetidamente.
	
	Using Python ThreadPool Class
	
		Exemplo 01:
		
			import time
			from multiprocessing.dummy import Pool

			def print_message(name):
				print(f"{name}: {time.ctime(time.time())}")
				time.sleep(1)

			threads = []
			for i in range(7):
				threads.append(f"Thread 0{i + 1}")

			print("\n\n# Um por vez")
			pool = Pool(1)
			pool.map(print_message, threads)
			pool.close()

			print("\n\n# 3 por vez")
			pool = Pool(3)
			pool.map(print_message, threads)
			pool.close()

			print("\n\n# 6 por vez")
			pool = Pool(6)
			pool.map(print_message, threads)
			pool.close()
	
	# --------------
	
	Using Python ThreadPoolExecutor Class
	
		Exemplo 01:
			
			import time
			from concurrent.futures import ThreadPoolExecutor

			def print_message(name):
				print(f"{name}: {time.ctime(time.time())}")
				time.sleep(1)

			threads = []

			for i in range(6):
				threads.append(f"Thread 0{i + 1}")

			print("\n\n# Um por vez")
			with ThreadPoolExecutor(max_workers=1) as t:
				t.map(print_message, threads)

			print("\n\n# 3 por vez")
			with ThreadPoolExecutor(max_workers=3) as t:
				t.map(print_message, threads)

			print("\n\n# 6 por vez")
			with ThreadPoolExecutor(max_workers=6) as t:
				t.map(print_message, threads)

	# --------------
	
	concurrent.futures.Future: √© respons√°vel por gerenciar a execu√ß√£o 
	ass√≠ncrona de qualquer cham√°vel (por exemplo, uma fun√ß√£o). Para obter um objeto Future, 
	deve-se chamar o m√©todo submit() em um executor. N√£o se deve criar inst√¢ncias de 
	Future diretamente via construtor.

		result(timeout=None) : Retorna o valor produzido pela chamada. Se a chamada ainda n√£o 
		                       tiver sido conclu√≠da, aguarda at√© timeout segundos. Se o tempo 
							   expirar, levanta TimeoutError. Sem timeout, o per√≠odo de 
							   espera √© ilimitado.

		cancel() 			 : Tenta cancelar a chamada. Se ela j√° estiver em execu√ß√£o ou for 
							   conclu√≠da, retorna False. Caso contr√°rio, cancela a chamada e 
							   retorna True.

		cancelled() 		 : Retorna True se a chamada foi cancelada com sucesso.

		running() 			 : Retorna True se a chamada ainda estiver em execu√ß√£o e n√£o 
		                       puder ser cancelada.

		done() 				 : Retorna True se a chamada j√° tiver sido conclu√≠da ou 
		                       cancelada com sucesso.
							   
							   
	Exemplo 01:
			
		from concurrent.futures import ThreadPoolExecutor
		from time import sleep

		def fala_oi(frases):
			print(">> Iniciando fala_oi")
			for frase in frases:
				print("Oi diz:", frase)
				sleep(1)
			print("<< fala_oi terminou")

		def fala_tchau(frases):
			print(">> Iniciando fala_tchau")
			for frase in frases:
				print("Tchau diz:", frase)
				sleep(1)
			print("<< fala_tchau terminou")

		if __name__ == "__main__":
			frases1 = ["mundo", "pessoa", "galera"]
			frases2 = ["at√© logo", "vai com Deus", "falou"]

			executor = ThreadPoolExecutor(max_workers=2)

			fut1 = executor.submit(fala_oi, frases1)
			fut2 = executor.submit(fala_tchau, frases2)

			print("fut1.done() ->", fut1.done())
			print("fut2.done() ->", fut2.done())

			sleep(2)

			print("fut1.done() ->", fut1.done())
			print("fut2.done() ->", fut2.done())

			# pega o resultado (sempre None, pois as fun√ß√µes n√£o retornam valor)
			print("fut1.result() ->", fut1.result())
			print("fut2.result() ->", fut2.result())

			executor.shutdown()



Python - Main Thread

	Em Python, o thread principal √© o thread inicial que come√ßa quando o interpretador 
	Python √© executado. √â o thread padr√£o dentro de um processo Python, respons√°vel 
	por gerenciar o programa e criar threads adicionais. Cada programa Python 
	possui pelo menos um thread de execu√ß√£o chamado thread principal.
	
	# --------------
	
	Accessing the Main Thread
	
		Exemplo 01:
		
			import threading
			print(threading.current_thread())
			
	
		threading.current_thread() : Retorna uma inst√¢ncia de threading.Thread representando 
									 a thread atual. 
		
		threading.main_thread()    : Retorna uma inst√¢ncia de threading.Thread representando 
									 a thread principal.
	
	# --------------
	
	Main Thread Behavior in Python
	
		Exemplo 01:
	
			import threading
			import time

			def func(delay):
				time.sleep(delay)
				if threading.current_thread() is threading.main_thread():
					print("Running on the main thread.")
				else:
					print("Running on a background thread.")

			t = threading.Thread(target=func, args=(2,))
			t.start()

			func(1)

			print("Main thread object:", threading.main_thread())
			print("Main thread has finished execution.")
			
	Main Thread Waiting for Other Threads
	
		Exemplo 01:
		
			from threading import Thread
			from time import sleep

			def my_function_1():
			   print("Worker 1 started")
			   sleep(1)
			   print("Worker 1 done")

			def my_function_2(main_thread):
			   print("Worker 2 waiting for Worker 1 to finish")
			   main_thread.join()
			   print("Worker 2 started")
			   sleep(1)
			   print("Worker 2 done")

			worker1 = Thread(target=my_function_1)
			worker2 = Thread(target=my_function_2, args=(worker1,))

			worker1.start()
			worker2.start()

			for num in range(6):
			   print("Main thread is still working on task", num)
			   sleep(0.60)

			worker1.join()
			print("Main thread Completed")
					
			
Python - Thread Priority


	Em Python, atualmente a prioridade do thread n√£o √© suportada diretamente pelo 
	m√≥dulo Thread. Ao contr√°rio do Java, o Python n√£o suporta prioridades de 
	threads, grupos de threads ou certos mecanismos de controle de threads, como 
	destruir, parar, suspender, retomar ou interromper threads.

	Definindo a prioridade do thread usando Sleep()
	
		Exemplo 01:
		
			import threading
			import time

			class myThread(threading.Thread):

				def __init__(self, **kwargs):
					threading.Thread.__init__(self) # constructor!!!
					self.name = kwargs["name"]
					self.priority = kwargs["priority"]

				def run(self):
					name = self.name
					time.sleep(1.0 * self.priority) # esse √© a linha principal
					print(f"{name} with prority {self.priority}")

			t1 = myThread(name="Thread_01", priority=4)
			t2 = myThread(name="Thread_02", priority=1)

			t1.start()
			t2.start()

			t1.join()
			t2.join()
				
			print("All threads finished.")
			
	
	Ajustando a prioridade de thread Python no Windows
	
		Exemplo 01:
		
			import threading
			import time
			import win32api
			import win32process
			import win32con

			def set_priority(p):
				"""
				Ajusta a prioridade da thread atual.
				p pode ser, por exemplo:
				  THREAD_PRIORITY_HIGHEST, THREAD_PRIORITY_LOWEST, THREAD_PRIORITY_NORMAL, etc.
				"""
				handle = win32api.GetCurrentThread()
				win32process.SetThreadPriority(handle, p)

			def hello():
				# Define prioridade alta para esta thread
				set_priority(win32con.THREAD_PRIORITY_HIGHEST)
				for i in range(5):
					print("Hello")
					time.sleep(0.2)

			def world():
				# Define prioridade baixa para esta thread
				set_priority(win32con.THREAD_PRIORITY_LOWEST)
				for i in range(5):
					print("World")
					time.sleep(0.2)

			if __name__ == "__main__":
				# Cria duas threads simples
				t1 = threading.Thread(target=hello)
				t2 = threading.Thread(target=world)

				t1.start()
				t2.start()

				t1.join()
				t2.join()

				print("Fim do programa idiota!")

			Para testar:

				1 - Instale o pywin32 se ainda n√£o tiver:

					pip install pywin32

				2 - Execute este script no Windows e observe que a thread ‚ÄúHello‚Äù (alta prioridade) 
					tende a imprimir mais r√°pido que ‚ÄúWorld‚Äù (baixa prioridade).
	
				
	# --------------
	
Python - Daemon Threads	

	Daemon Thread
		- √â uma thread de "servi√ßo" que roda em segundo plano.
		- Finaliza automaticamente quando todas as threads n√£o-daemon 
		  terminam, mesmo que ela ainda esteja executando.
		- Boa para tarefas auxiliares (como monitoramento, limpeza, etc.) 
		  que n√£o precisam impedir o encerramento do programa.

	üî© Non-Daemon Thread (padr√£o)
		- √â uma thread ‚Äúprincipal‚Äù ou ‚Äúde trabalho‚Äù.
	    - Impede o programa de terminar at√© que ela mesma termine.
		- Usada para tarefas que devem ser conclu√≠das, como salvar arquivos, 
		  processar dados, etc.
	
	
	Creating a Daemon Thread in Python
		
		Exemplo 01:
		
			import threading
			import time

			def print_message(name, delay, limit):
				i = 0
				while i < limit:
					print(f"{name}: {time.time()}")
					time.sleep(delay)
					i+=1

			class myThread(threading.Thread):
				def __init__(self, **kwargs):
					super().__init__(name=kwargs["name"], daemon=kwargs["daemon"]) # AQUI!
					self.delay = kwargs["delay"]
					self.limit = kwargs["limit"]

				def run(self):
					print(f"{self.name} is started.")
					print_message(self.name, self.delay, self.limit)
					print(f"{self.name} is done!")

			t1 = myThread(name="Thread 01", delay=1, limit=5, daemon=False) # AQUI!
			t2 = myThread(name="Thread 02", delay=3, limit=2, daemon=True)  # AQUI!

			t1.start()
			t2.start()

			time.sleep(2)
			print("Exiting MainThread!")